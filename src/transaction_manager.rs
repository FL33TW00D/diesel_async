use diesel::{result::DatabaseErrorKind, QueryResult};

use crate::{AsyncConnection, SimpleAsyncConnection};

#[async_trait::async_trait]
pub trait TransactionManager<Conn: AsyncConnection> {
    /// Data stored as part of the connection implementation
    /// to track the current transaction state of a connection
    type TransactionStateData;

    /// Begin a new transaction or savepoint
    ///
    /// If the transaction depth is greater than 0,
    /// this should create a savepoint instead.
    /// This function is expected to increment the transaction depth by 1.
    async fn begin_transaction(conn: &mut Conn) -> QueryResult<()>;

    /// Rollback the inner-most transaction or savepoint
    ///
    /// If the transaction depth is greater than 1,
    /// this should rollback to the most recent savepoint.
    /// This function is expected to decrement the transaction depth by 1.
    async fn rollback_transaction(conn: &mut Conn) -> QueryResult<()>;

    /// Commit the inner-most transaction or savepoint
    ///
    /// If the transaction depth is greater than 1,
    /// this should release the most recent savepoint.
    /// This function is expected to decrement the transaction depth by 1.
    async fn commit_transaction(conn: &mut Conn) -> QueryResult<()>;

    /// Fetch the current transaction depth
    ///
    /// Used to ensure that `begin_test_transaction` is not called when already
    /// inside of a transaction.
    fn get_transaction_depth(conn: &mut Conn) -> u32;
}

#[derive(Default)]
pub struct AnsiTransactionManager {
    transaction_depth: i32,
}

impl AnsiTransactionManager {
    /// Begin a transaction with custom SQL
    ///
    /// This is used by connections to implement more complex transaction APIs
    /// to set things such as isolation levels.
    /// Returns an error if already inside of a transaction.
    pub async fn begin_transaction_sql<Conn>(conn: &mut Conn, sql: &str) -> QueryResult<()>
    where
        Conn: AsyncConnection<TransactionManager = Self>,
    {
        use diesel::result::Error::AlreadyInTransaction;

        if conn.transaction_state().transaction_depth == 0 {
            let r = conn.batch_execute(sql).await;
            conn.transaction_state().change_transaction_depth(1, r)
        } else {
            Err(AlreadyInTransaction)
        }
    }

    fn change_transaction_depth<T>(&mut self, by: i32, query: QueryResult<T>) -> QueryResult<()> {
        if query.is_ok() {
            self.transaction_depth += by;
        }
        query.map(|_| ())
    }
}

#[async_trait::async_trait]
impl<Conn> TransactionManager<Conn> for AnsiTransactionManager
where
    Conn: AsyncConnection<TransactionManager = Self>,
{
    type TransactionStateData = Self;

    async fn begin_transaction(conn: &mut Conn) -> QueryResult<()> {
        let transaction_depth = conn.transaction_state().transaction_depth;
        let r = if transaction_depth == 0 {
            SimpleAsyncConnection::batch_execute(conn, "BEGIN").await
        } else {
            SimpleAsyncConnection::batch_execute(
                conn,
                &format!("SAVEPOINT diesel_savepoint_{}", transaction_depth),
            )
            .await
        };
        conn.transaction_state().change_transaction_depth(1, r)
    }

    async fn rollback_transaction(conn: &mut Conn) -> QueryResult<()> {
        let transaction_depth = conn.transaction_state().transaction_depth;
        let r = if transaction_depth == 1 {
            SimpleAsyncConnection::batch_execute(conn, "ROLLBACK").await
        } else {
            SimpleAsyncConnection::batch_execute(
                conn,
                &format!(
                    "ROLLBACK TO SAVEPOINT diesel_savepoint_{}",
                    transaction_depth - 1
                ),
            )
            .await
        };
        conn.transaction_state().change_transaction_depth(-1, r)
    }

    /// If the transaction fails to commit due to a `SerializationFailure` or a
    /// `ReadOnlyTransaction` a rollback will be attempted. If the rollback succeeds,
    /// the original error will be returned, otherwise the error generated by the rollback
    /// will be returned. In the second case the connection should be considered broken
    /// as it contains a uncommitted unabortable open transaction.
    async fn commit_transaction(conn: &mut Conn) -> QueryResult<()> {
        let transaction_depth = conn.transaction_state().transaction_depth;
        if transaction_depth <= 1 {
            match SimpleAsyncConnection::batch_execute(conn, "COMMIT").await {
                // When any of these kinds of error happen on `COMMIT`, it is expected
                // that a `ROLLBACK` would succeed, leaving the transaction in a non-broken state.
                // If there are other such errors, it is fine to add them here.
                e @ Err(diesel::result::Error::DatabaseError(
                    DatabaseErrorKind::SerializationFailure,
                    _,
                ))
                | e @ Err(diesel::result::Error::DatabaseError(
                    DatabaseErrorKind::ReadOnlyTransaction,
                    _,
                )) => {
                    let r = SimpleAsyncConnection::batch_execute(conn, "ROLLBACK").await;
                    conn.transaction_state().change_transaction_depth(-1, r)?;
                    e.map(|_| ())
                }
                result => conn
                    .transaction_state()
                    .change_transaction_depth(-1, result),
            }
        } else {
            match SimpleAsyncConnection::batch_execute(
                conn,
                &format!(
                    "RELEASE SAVEPOINT diesel_savepoint_{}",
                    transaction_depth - 1,
                ),
            )
            .await
            {
                Ok(_) => conn
                    .transaction_state()
                    .change_transaction_depth(-1, Ok(())),
                // Postgres treats error (like syntax errors, missing tables, â€¦)
                // as fatal errors and does not accept any new commands till the
                // transaction is aborted or we've done a rollback
                // To mirror the behaviour above we attempt to rollback
                // to the last savepoint if we hit such a case
                Err(diesel::result::Error::DatabaseError(DatabaseErrorKind::Unknown, msg))
                    if msg.message().starts_with("current transaction is aborted") =>
                {
                    let r = SimpleAsyncConnection::batch_execute(
                        conn,
                        &format!(
                            "ROLLBACK TO SAVEPOINT diesel_savepoint_{}",
                            transaction_depth - 1
                        ),
                    )
                    .await;
                    conn.transaction_state().change_transaction_depth(-1, r)?;
                    Err(diesel::result::Error::DatabaseError(
                        DatabaseErrorKind::Unknown,
                        msg,
                    ))
                }
                Err(e) => panic!("{}", e),
            }
        }
    }

    fn get_transaction_depth(conn: &mut Conn) -> u32 {
        conn.transaction_state().transaction_depth as u32
    }
}
